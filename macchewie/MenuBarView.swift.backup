//
//  MenuBarView.swift
//  macchewie
//
//  Created by Camille Duprat on 10/09/2025.
//

import SwiftUI
import Foundation
import AppKit
import CoreGraphics

// MARK: - Message Structure
enum MessageSender {
    case user
    case agent
}

struct ChatMessage: Identifiable {
    let id = UUID()
    let text: String
    let image: NSImage?
    let sender: MessageSender
    let timestamp: Date
    
    init(text: String, image: NSImage? = nil, sender: MessageSender = .user) {
        self.text = text
        self.image = image
        self.sender = sender
        self.timestamp = Date()
    }
}

// MARK: - Agent Output Models
struct AgentOutput {
    let solutions: [String]
    let categories: [Category]
}

struct Category {
    let title: String
    let arguments: [Argument]
}

struct Argument {
    let text: String
    let type: ArgumentType
}

enum ArgumentType {
    case issue
    case good
}

// MARK: - Agent Output Parser
class AgentOutputParser {
    static func parse(_ text: String) -> AgentOutput {
        let lines = text.components(separatedBy: .newlines)
        var solutions: [String] = []
        var categories: [Category] = []
        var currentCategory: Category?
        var currentArguments: [Argument] = []
        
        for line in lines {
            let trimmedLine = line.trimmingCharacters(in: .whitespacesAndNewlines)
            guard !trimmedLine.isEmpty else { continue }
            
            if trimmedLine.hasPrefix("‚úÖ") {
                // Solution
                let solutionText = String(trimmedLine.dropFirst(2)).trimmingCharacters(in: .whitespacesAndNewlines)
                if !solutionText.isEmpty {
                    solutions.append(solutionText)
                }
            } else if trimmedLine.hasPrefix("‚≠êÔ∏è") {
                // Category - save previous category if exists
                if let category = currentCategory {
                    categories.append(category)
                }
                
                let categoryTitle = String(trimmedLine.dropFirst(2)).trimmingCharacters(in: .whitespacesAndNewlines)
                currentCategory = Category(title: categoryTitle, arguments: [])
                currentArguments = []
            } else if trimmedLine.hasPrefix("üî¥") {
                // Issue argument
                let argumentText = String(trimmedLine.dropFirst(2)).trimmingCharacters(in: .whitespacesAndNewlines)
                if !argumentText.isEmpty {
                    currentArguments.append(Argument(text: argumentText, type: .issue))
                }
            } else if trimmedLine.hasPrefix("üü¢") {
                // Good argument
                let argumentText = String(trimmedLine.dropFirst(2)).trimmingCharacters(in: .whitespacesAndNewlines)
                if !argumentText.isEmpty {
                    currentArguments.append(Argument(text: argumentText, type: .good))
                }
            }
        }
        
        // Add the last category
        if let category = currentCategory {
            let finalCategory = Category(title: category.title, arguments: currentArguments)
            categories.append(finalCategory)
        }
        
        return AgentOutput(solutions: solutions, categories: categories)
    }
}

// MARK: - Card Components
struct SolutionCard: View {
    let solution: String
    let onMoreTapped: () -> Void
    
    var body: some View {
        VStack(alignment: .leading, spacing: 8) {
            HStack(alignment: .top, spacing: 8) {
                Text("‚úÖ")
                    .font(.system(size: 16))
                
                Text(solution)
                    .font(.system(size: 14, weight: .regular))
                    .foregroundStyle(Color.primary)
                    .multilineTextAlignment(.leading)
                
                Spacer()
            }
            
            HStack {
                Spacer()
                Button("More") {
                    onMoreTapped()
                }
                .buttonStyle(.bordered)
                .controlSize(.small)
                .foregroundStyle(Color.green)
            }
        }
        .padding(.horizontal, 16)
        .padding(.vertical, 16)
        .background(
            RoundedRectangle(cornerRadius: 16)
                .fill(Color.green.opacity(0.1))
                .overlay(
                    RoundedRectangle(cornerRadius: 16)
                        .stroke(Color.green.opacity(0.3), lineWidth: 1)
                )
        )
    }
}

struct CategoryTitle: View {
    let title: String
    
    var body: some View {
        HStack {
            Text("‚≠êÔ∏è")
                .font(.system(size: 14))
            
            Text(title)
                .font(.system(size: 14, weight: .medium))
                .foregroundStyle(Color.primary)
            
            Spacer()
        }
        .padding(.horizontal, 0)
        .padding(.vertical, 8)
    }
}

struct ArgumentCard: View {
    let argument: Argument
    
    var body: some View {
        HStack(alignment: .top, spacing: 8) {
            Text(argument.type == .issue ? "üî¥" : "üü¢")
                .font(.system(size: 14))
            
            Text(argument.text)
                .font(.system(size: 14))
                .foregroundStyle(Color.primary)
                .multilineTextAlignment(.leading)
            
            Spacer()
        }
        .padding(.horizontal, 16)
        .padding(.vertical, 16)
        .background(
            RoundedRectangle(cornerRadius: 16)
                .fill(argument.type == .issue ? Color.red.opacity(0.1) : Color.green.opacity(0.1))
                .overlay(
                    RoundedRectangle(cornerRadius: 16)
                        .stroke(argument.type == .issue ? Color.red.opacity(0.3) : Color.green.opacity(0.3), lineWidth: 1)
                )
        )
    }
}

struct AgentOutputView: View {
    let output: AgentOutput
    let onSolutionMoreTapped: (String) -> Void
    
    var body: some View {
        VStack(alignment: .leading, spacing: 16) {
            // Solutions first
            if !output.solutions.isEmpty {
                VStack(alignment: .leading, spacing: 8) {
                    ForEach(output.solutions.indices, id: \.self) { index in
                        SolutionCard(solution: output.solutions[index]) {
                            onSolutionMoreTapped(output.solutions[index])
                        }
                    }
                }
            }
            
            // Then categories with their arguments
            ForEach(output.categories.indices, id: \.self) { categoryIndex in
                let category = output.categories[categoryIndex]
                
                VStack(alignment: .leading, spacing: 8) {
                    CategoryTitle(title: category.title)
                    
                    ForEach(category.arguments.indices, id: \.self) { argumentIndex in
                        ArgumentCard(argument: category.arguments[argumentIndex])
                    }
                }
            }
        }
    }
}

struct MenuBarView: View {
    @State private var chatText: String = ""
    @State private var messages: [ChatMessage] = []
    @State private var isLoading: Bool = false
    @StateObject private var dustService = DustService()
    @State private var selectedImage: NSImage?
    @State private var loadingMessageIndex: Int = 0
    @State private var loadingTimer: Timer?
    @State private var selectedTags: Set<String> = []
    
    // Multi-step flow state
    @State private var currentStep: Int = 1
    @State private var selectedInputType: String = ""
    @State private var selectedProductType: String = ""
    @State private var descriptionText: String = ""
    @State private var isCapturingScreenshot: Bool = false
    @State private var screenshotTimeoutTimer: Timer?
    @State private var expandedImageIds: Set<UUID> = []
    
    // Loading messages to cycle through
    private let loadingMessages = [
        "Analysing the image",
        "Fetching proper refs", 
        "Mixing it all together",
        "Cooking a dope answer",
        "Sugar coating the truth"
    ]
    
    // Computed property for status message
    private var statusMessage: String {
            return ""
    }
    
    // Computed property for placeholder text
    private var placeholderText: String {
        if isLoading {
            return loadingMessages[loadingMessageIndex]
        } else if selectedImage != nil {
            switch currentStep {
            case 1:
                return "Select input type"
            case 2:
                return "Select product type"
            case 3:
                return "What is the app about?"
            default:
                return "Ask anything"
            }
        } else {
            return "Ask anything"
        }
    }
    
    init() {
        print("üì± [DEBUG] MenuBarView initializing")
    }
    
    // Start cycling through loading messages
    private func startLoadingMessages() {
        loadingMessageIndex = 0
        loadingTimer = Timer.scheduledTimer(withTimeInterval: 1.5, repeats: true) { _ in
            loadingMessageIndex = (loadingMessageIndex + 1) % loadingMessages.count
        }
    }
    
    // Stop cycling through loading messages
    private func stopLoadingMessages() {
        loadingTimer?.invalidate()
        loadingTimer = nil
        loadingMessageIndex = 0
    }
    
    var body: some View {
        VStack(spacing: 16) {
            headerSection
            conversationArea
            chatInputSection
        }
        .frame(minWidth: 380, maxWidth: .infinity)
        .frame(minHeight: messages.isEmpty ? 120 : 720, maxHeight: .infinity)
    }
    
    // MARK: - Header Section
    private var headerSection: some View {
        HStack {
            // Left side: Back chevron + Title
            HStack(spacing: 8) {
                Button(action: {
                    // Back action - could be used to close or navigate back
                }) {
                    Image(systemName: "chevron.left")
                        .font(.system(size: 16, weight: .medium))
                        .foregroundColor(.secondary)
                }
                .buttonStyle(.plain)
                
                Text("Fits profiles")
                    .font(.system(size: 18, weight: .semibold))
                    .foregroundColor(.primary)
            }
            
            Spacer()
            
            // Right side: Reset button
            Button(action: {
                resetConversation()
            }) {
                Image(systemName: "arrow.clockwise")
                    .font(.system(size: 16, weight: .medium))
                    .foregroundColor(.secondary)
            }
            .buttonStyle(.plain)
        }
        .padding(.horizontal, 16)
        .padding(.vertical, 12)
        .background(Color(NSColor.controlBackgroundColor))
    }
    
    // MARK: - Conversation Area
    private var conversationArea: some View {
            // Messages area - animated pop-in above input
            if !messages.isEmpty {
                ScrollViewReader { proxy in
                    ScrollView {
                        LazyVStack(spacing: 24) {
                            ForEach(messages.indices, id: \.self) { index in
                                let message = messages[index]
                                
                                // Check if this message contains agent output format
                                if message.text.contains("‚≠êÔ∏è") || message.text.contains("üî¥") || message.text.contains("üü¢") || message.text.contains("‚úÖ") {
                                    // Parse and display as structured cards
                                    let output = AgentOutputParser.parse(message.text)
                                    AgentOutputView(output: output) { solution in
                                        sendTaggedMessage(solution)
                                    }
                                    .padding(.horizontal, 8)
                                    .id("message-\(index)")
                                } else {
                                    // Display as regular message with optional image
                                    VStack(alignment: message.sender == .user ? .trailing : .leading, spacing: 8) {
                                        if let image = message.image {
                                            // Display image with expand functionality
                                            VStack(alignment: message.sender == .user ? .trailing : .leading, spacing: 8) {
                                                HStack {
                                                    if message.sender == .user {
                                                        Spacer()
                                                    }
                                                    
                                                    let isExpanded = expandedImageIds.contains(message.id)
                                                    
                                            Image(nsImage: image)
                                                .resizable()
                                                .aspectRatio(contentMode: .fit)
                                                        .frame(
                                                            maxHeight: isExpanded ? 500 : 300,
                                                            maxWidth: isExpanded ? .infinity : 300
                                                        )
                                                        .background(
                                                            message.sender == .user 
                                                            ? Color.accentColor.opacity(0.8) 
                                                            : Color.accentColor.opacity(0.15), 
                                                            in: RoundedRectangle(cornerRadius: 16)
                                                        )
                                                        .clipShape(RoundedRectangle(cornerRadius: 16))
                                                .shadow(radius: 4)
                                                        .animation(.easeInOut(duration: 0.3), value: isExpanded)
                                                    
                                                    if message.sender == .agent {
                                                        Spacer()
                                                    }
                                        }
                                        
                                                // Expand/Collapse button
                                            HStack {
                                                    if message.sender == .user {
                                                        Spacer()
                                                    }
                                                    
                                                    Button(action: {
                                                        if expandedImageIds.contains(message.id) {
                                                            expandedImageIds.remove(message.id)
                                                        } else {
                                                            expandedImageIds.insert(message.id)
                                                        }
                                                    }) {
                                                        Image(systemName: expandedImageIds.contains(message.id) ? "arrow.down.right.and.arrow.up.left" : "arrow.up.left.and.arrow.down.right")
                                                            .font(.system(size: 12))
                                                            .foregroundColor(.secondary)
                                                            .padding(6)
                                                            .background(
                                                                RoundedRectangle(cornerRadius: 8)
                                                                    .fill(Color(NSColor.controlBackgroundColor))
                                                            )
                                                    }
                                                    .buttonStyle(.plain)
                                                    .help(expandedImageIds.contains(message.id) ? "Collapse image" : "Expand image")
                                                    
                                                if message.sender == .agent {
                                                        Spacer()
                                                    }
                                                }
                                            }
                                        }
                                        
                                        if !message.text.isEmpty {
                                            HStack {
                                                if message.sender == .user {
                                                    Spacer()
                                                }
                                                
                                                Text(message.text)
                                                    .padding(.horizontal, 16)
                                                    .padding(.vertical, 16)
                                                    .background(
                                                        message.sender == .user 
                                                        ? Color.accentColor.opacity(0.8) 
                                                        : Color.accentColor.opacity(0.15), 
                                                        in: RoundedRectangle(cornerRadius: 16)
                                                    )
                                                    .foregroundStyle(
                                                        message.sender == .user 
                                                        ? Color.white 
                                                        : Color.primary
                                                    )
                                                    .frame(maxWidth: 300, alignment: message.sender == .user ? .trailing : .leading)
                                                
                                                if message.sender == .agent {
                                                    Spacer()
                                                }
                                            }
                                        }
                                    }
                                    .id("message-\(index)")
                                }
                            }
                        }
                        .padding(.horizontal, 8)
                        .padding(.vertical, 8)
                    }
                    .onChange(of: messages.count) { _ in
                        // Scroll to the latest message when new messages are added
                        withAnimation(.easeInOut(duration: 0.3)) {
                            proxy.scrollTo("message-\(messages.count - 1)", anchor: .bottom)
                        }
                    }
                }
            }
            
            
            // Chat input - always at bottom
            VStack(spacing: 0) {
                
                
                HStack(spacing: 8) {
                    // Screen scan button - only show when no image is uploaded
                    if selectedImage == nil {
                    Button(action: {
                            if !isLoading && !isCapturingScreenshot {
                                captureScreenshot()
                        }
                    }) {
                        Image(systemName: isCapturingScreenshot ? "camera.fill" : "camera.viewfinder")
                            .font(.system(size: 16))
                            .foregroundColor(isLoading ? .secondary.opacity(0.5) : (isCapturingScreenshot ? .green : .secondary))
                            .frame(width: 44, height: 44)
                            .background(
                                RoundedRectangle(cornerRadius: 12)
                                    .fill(isLoading ? Color(NSColor.controlBackgroundColor).opacity(0.5) : (isCapturingScreenshot ? Color.green.opacity(0.1) : Color(NSColor.controlBackgroundColor)))
                            )
                    }
                    .buttonStyle(.plain)
                        .disabled(isLoading || isCapturingScreenshot)
                    .overlay(
                        RoundedRectangle(cornerRadius: 12)
                                .stroke(isCapturingScreenshot ? Color.green.opacity(0.3) : Color(NSColor.separatorColor), lineWidth: 0.5)
                    )
                        .help(isLoading ? "Please wait..." : (isCapturingScreenshot ? "Capturing screenshot..." : "Take screenshot of your design"))
                    }
                    
                    // Image upload button
                    ZStack {
                        Button(action: {
                            if !isLoading && selectedImage == nil {
                                selectImageFile()
                            }
                        }) {
                            Image(systemName: selectedImage != nil ? "photo.fill" : "photo")
                                .font(.system(size: 16))
                                .foregroundColor(isLoading ? .secondary.opacity(0.5) : (selectedImage != nil ? .blue : .secondary))
                                .frame(width: 44, height: 44)
                                .background(
                                    RoundedRectangle(cornerRadius: 12)
                                        .fill(isLoading ? Color(NSColor.controlBackgroundColor).opacity(0.5) : (selectedImage != nil ? .white : Color(NSColor.controlBackgroundColor)))
                                )
                        }
                        .buttonStyle(.plain)
                        .disabled(isLoading)
                        .overlay(
                            RoundedRectangle(cornerRadius: 12)
                                .stroke(Color(NSColor.separatorColor), lineWidth: 0.5)
                        )
                        .help(isLoading ? "Please wait..." : (selectedImage != nil ? "Remove image" : "Upload image"))
                        
                        // Red X mark overlay when image is selected
                        if selectedImage != nil {
                            Button(action: {
                                if !isLoading {
                                    selectedImage = nil
                                }
                            }) {
                                Image(systemName: "xmark.circle.fill")
                                    .font(.system(size: 13))
                                    .foregroundColor(.red)
                                    .background(Color.white, in: Circle())
                            }
                            .buttonStyle(.plain)
                            .offset(y: -15)
                            .offset(x: 17)
                        }
                    }
                    
                    // Text field with send button inside
                    ZStack(alignment: .trailing) {
                        VStack(spacing: 0) {
                            // Text input - only when no image (step 3 has its own text input)
                            if selectedImage == nil {
                        TextField(placeholderText, text: $chatText)
                            .textFieldStyle(.plain)
                            .padding(.horizontal, 16)
                            .padding(.trailing, 40) // Make space for the send button
                                    .frame(height: 44)
                                    .background(Color.clear)
                                    .disabled(isLoading)
                                    .onSubmit {
                                        if !isLoading {
                                            sendMessage()
                                        }
                                    }
                            }
                            
                            // Multi-step flow when image is present
                            if selectedImage != nil {
                                VStack(spacing: 0) {
                                    // Step content
                                    switch currentStep {
                                    case 1:
                                        // Step 1: Input type selection - no back button
                                        VStack(spacing: 12) {
                                            // Step title
                                            HStack {
                                                Text("Image type?")
                                                    .font(.system(size: 14, weight: .regular))
                                                    .foregroundColor(.primary .opacity(0.5))
                                                Spacer()
                                            }
                                            .padding(.horizontal, 16)
                                            .padding(.top, 16)
                                            
                                            // Tags
                                            HStack(spacing: 4) {
                                                Button("Component") {
                                                    selectedInputType = "Component"
                                                }
                                                .buttonStyle(.plain)
                                                .padding(.horizontal, 12)
                                                .padding(.vertical, 6)
                            .background(
                                                    RoundedRectangle(cornerRadius: 80)
                                                        .fill(selectedInputType == "Component" ? Color.white : Color.white.opacity(0.1))
                            )
                            .overlay(
                                                    RoundedRectangle(cornerRadius: 80)
                                                        .stroke(selectedInputType == "Component" ? Color.clear : Color.white.opacity(0.2), lineWidth: 1)
                                                )
                                                .foregroundStyle(selectedInputType == "Component" ? Color.blue : Color.white.opacity(0.5))
                                                
                                                Button("Screen") {
                                                    selectedInputType = "Screen"
                                                }
                                                .buttonStyle(.plain)
                                                .padding(.horizontal, 12)
                                                .padding(.vertical, 6)
                                                .background(
                                                    RoundedRectangle(cornerRadius: 80)
                                                        .fill(selectedInputType == "Screen" ? Color.white : Color.white.opacity(0.1))
                                                )
                                                .overlay(
                                                    RoundedRectangle(cornerRadius: 80)
                                                        .stroke(selectedInputType == "Screen" ? Color.clear : Color.white.opacity(0.2), lineWidth: 1)
                                                )
                                                .foregroundStyle(selectedInputType == "Screen" ? Color.blue : Color.white.opacity(0.5))
                                                
                                                Button("Flow") {
                                                    selectedInputType = "Flow"
                                                }
                                                .buttonStyle(.plain)
                                                .padding(.horizontal, 12)
                                                .padding(.vertical, 6)
                                                .background(
                                                    RoundedRectangle(cornerRadius: 80)
                                                        .fill(selectedInputType == "Flow" ? Color.white : Color.white.opacity(0.1))
                                                )
                                                .overlay(
                                                    RoundedRectangle(cornerRadius: 80)
                                                        .stroke(selectedInputType == "Flow" ? Color.clear : Color.white.opacity(0.2), lineWidth: 1)
                                                )
                                                .foregroundStyle(selectedInputType == "Flow" ? Color.blue : Color.white.opacity(0.5))
                                                
                                                Spacer()
                                            }
                                            .padding(.horizontal, 16)
                                            .padding(.bottom, 16)
                                        }
                                        
                                    case 2:
                                        // Step 2: Product type selection - with back button
                                        VStack(spacing: 12) {
                                            // Step title with back button
                                            HStack {
                                                Button(action: {
                                                    currentStep = 1
                                                }) {
                                                    Image(systemName: "chevron.left")
                                                        .font(.system(size: 14, weight: .regular))
                                                        .foregroundColor(.primary .opacity(0.5))
                                                }
                                                .buttonStyle(.plain)
                                                
                                                Text("Product type?")
                                                    .font(.system(size: 14, weight: .regular))
                                                    .foregroundColor(.primary .opacity(0.5))
                                                
                                                Spacer()
                                            }
                                            .padding(.horizontal, 16)
                                            .padding(.top, 16)
                                            
                                            // Tags
            HStack(spacing: 4) {
                                                Button("SaaS") {
                                                    selectedProductType = "SaaS"
                                                }
                                                .buttonStyle(.plain)
                                                .padding(.horizontal, 12)
                                                .padding(.vertical, 6)
                                                .background(
                                                    RoundedRectangle(cornerRadius: 80)
                                                        .fill(selectedProductType == "SaaS" ? Color.white : Color.white.opacity(0.1))
                                                )
                                                .overlay(
                                                    RoundedRectangle(cornerRadius: 80)
                                                        .stroke(selectedProductType == "SaaS" ? Color.clear : Color.white.opacity(0.2), lineWidth: 1)
                                                )
                                                .foregroundStyle(selectedProductType == "SaaS" ? Color.blue : Color.white.opacity(0.5))
                
                                                Button("Mobile") {
                                                    selectedProductType = "Mobile"
                                                }
                                                .buttonStyle(.plain)
                                                .padding(.horizontal, 12)
                                                .padding(.vertical, 6)
                                                .background(
                                                    RoundedRectangle(cornerRadius: 80)
                                                        .fill(selectedProductType == "Mobile" ? Color.white : Color.white.opacity(0.1))
                                                )
                                                .overlay(
                                                    RoundedRectangle(cornerRadius: 80)
                                                        .stroke(selectedProductType == "Mobile" ? Color.clear : Color.white.opacity(0.2), lineWidth: 1)
                                                )
                                                .foregroundStyle(selectedProductType == "Mobile" ? Color.blue : Color.white.opacity(0.5))
                                                
                                                Button("Ecommerce") {
                                                    selectedProductType = "Ecommerce"
                                                }
                                                .buttonStyle(.plain)
                                                .padding(.horizontal, 12)
                                                .padding(.vertical, 6)
                                                .background(
                                                    RoundedRectangle(cornerRadius: 80)
                                                        .fill(selectedProductType == "Ecommerce" ? Color.white : Color.white.opacity(0.1))
                                                )
                                                .overlay(
                                                    RoundedRectangle(cornerRadius: 80)
                                                        .stroke(selectedProductType == "Ecommerce" ? Color.clear : Color.white.opacity(0.2), lineWidth: 1)
                                                )
                                                .foregroundStyle(selectedProductType == "Ecommerce" ? Color.blue : Color.white.opacity(0.5))
                                                
                                                Spacer()
                                            }
                                            .padding(.horizontal, 16)
                                            .padding(.bottom, 16)
                                        }
                                        
                                    case 3:
                                        // Step 3: Description - with back button and text input
                                        VStack(spacing: 12) {
                                            // Step title with back button
                                            HStack {
                                                Button(action: {
                                                    currentStep = 2
                                                }) {
                                                    Image(systemName: "chevron.left")
                                                        .font(.system(size: 14, weight: .regular))
                                                        .foregroundColor(.primary .opacity(0.5))
                                                }
                                                .buttonStyle(.plain)
                                                
                                                Text("Additional context?")
                                                    .font(.system(size: 14, weight: .regular))
                                                    .foregroundColor(.primary .opacity(0.5))
                                                
                                                Spacer()
                                            }
                                            .padding(.horizontal, 16)
                                            .padding(.top, 16)
                                            
                                            // Text input for step 3 with send button
                                            ZStack(alignment: .trailing) {
                                                TextField(placeholderText, text: $descriptionText)
                                                    .textFieldStyle(.plain)
                                                    .padding(.horizontal, 16)
                                                    .padding(.vertical, 12)
                                                    .padding(.trailing, 40) // Make space for the send button
                                                    .background(Color.clear)
                            .disabled(isLoading)
                            .onSubmit {
                                if !isLoading {
                                                            handleStepAction()
                                                        }
                                                    }
                                                
                                                
                                                // Send button for step 3
                                                Button(action: {
                                                    handleStepAction()
                                                }) {
                            if isLoading {
                                ProgressView()
                                    .scaleEffect(0.8)
                            } else {
                                                        Image(systemName: "arrow.up.circle.fill")
                                                            .font(.system(size: 16, weight: .regular))
                                    .foregroundColor(.white)
                            }
                        }
                        .buttonStyle(.borderless)
                                                .disabled(isButtonDisabled())
                        .padding(.trailing, 12)
                                            }
                                        }
                                        
                                    default:
                                        EmptyView()
                                    }
                                    
                                    // Progress bar at bottom
                                    GeometryReader { geometry in
                                        ZStack(alignment: .leading) {
                                            // Background bar
                                            Rectangle()
                                                .fill(Color.secondary.opacity(0.3))
                                                .frame(height: 1)
                                            
                                            // Progress bar
                                            Rectangle()
                                                .fill(Color.white)
                                                .frame(width: geometry.size.width * getProgressPercentage(), height: 1)
                                        }
                                    }
                                    .frame(height: 1)
                                    .padding(.horizontal, 20)
                                }
                            }
                        }
                .background(
                    RoundedRectangle(cornerRadius: 12)
                                    .fill(isLoading ? Color(NSColor.controlBackgroundColor).opacity(0.5) : Color(NSColor.controlBackgroundColor))
                )
                .overlay(
                    RoundedRectangle(cornerRadius: 12)
                        .stroke(Color(NSColor.separatorColor), lineWidth: 0.5)
                )
                        
                        // Send button - only show when no image (step 3 has its own send button)
                        if selectedImage == nil {
                            Button(action: {
                                sendMessage()
                            }) {
                                if isLoading {
                                    ProgressView()
                                        .scaleEffect(0.8)
                                } else {
                                    // Show send icon for no image
                                    Image(systemName: "arrow.up.circle.fill")
                                        .font(.system(size: 14, weight: .regular))
                                        .foregroundColor(.white)
                                }
                            }
                            .buttonStyle(.borderless)
                            .disabled(isButtonDisabled())
                            .padding(.trailing, 12)
                            .padding(.bottom, 0)
                        }
                        
                        // Next button for steps 1 and 2 - positioned on the right side
                        if selectedImage != nil && currentStep < 3 {
                            Button(action: {
                                handleStepAction()
                            }) {
                                Image(systemName: "arrow.right")
                                    .font(.system(size: 14, weight: .regular))
                                    .foregroundColor(Color.white.opacity(0.5))
                            }
                            .buttonStyle(.borderless)
                            .disabled(isButtonDisabled())
                            .padding(.trailing, 12)
                            .padding(.bottom, 8)
                        }
                    }
                }
            }
            }
            
        }
        .padding(12)
        .frame(minWidth: 380, maxWidth: .infinity)
        .frame(minHeight: messages.isEmpty ? 120 : 720, maxHeight: .infinity)
    }
    
    private func selectImageFile() {
        let panel = NSOpenPanel()
        panel.allowedContentTypes = [.image]
        panel.allowsMultipleSelection = false
        panel.canChooseDirectories = false
        panel.canChooseFiles = true
        
        if panel.runModal() == .OK, let url = panel.url {
            selectedImage = NSImage(contentsOf: url)
        }
    }
    
    private func openWebpage() {
        // Opens the Chewie AI frontend interface
        guard let url = URL(string: "https://maximegerardin97-max.github.io/chewieai-fe-clean/") else { return }
        NSWorkspace.shared.open(url)
    }
    
    private func toggleTag(_ tag: String) {
        if selectedTags.contains(tag) {
            selectedTags.remove(tag)
        } else {
            selectedTags.insert(tag)
        }
    }
    
    private func getProgressPercentage() -> Double {
        switch currentStep {
        case 1:
            return 0.33 // 33%
        case 2:
            return 0.66 // 66%
        case 3:
            return 1.0  // 100%
        default:
            return 0.0
        }
    }
    
    private func captureScreenshot() {
        print("üì± [DEBUG] Screenshot capture button tapped")
        
        // Set capturing state
        isCapturingScreenshot = true
        
        // Start timeout timer (30 seconds)
        screenshotTimeoutTimer?.invalidate()
        screenshotTimeoutTimer = Timer.scheduledTimer(withTimeInterval: 30.0, repeats: false) { _ in
            print("üì± [DEBUG] Screenshot capture timeout - resetting state")
            self.isCapturingScreenshot = false
        }
        
        // Hide the app window
        if let window = NSApplication.shared.windows.first {
            window.orderOut(nil)
        }
        
        // Use screencapture command line tool for area selection
        DispatchQueue.main.asyncAfter(deadline: .now() + 0.5) {
            let task = Process()
            task.launchPath = "/usr/sbin/screencapture"
            task.arguments = ["-i", "-c"] // -i for interactive (area selection), -c for clipboard
            
            print("üì± [DEBUG] Launching screencapture command")
            task.launch()
            task.waitUntilExit()
            
            print("üì± [DEBUG] Screencapture command completed with exit code: \(task.terminationStatus)")
            
            // Wait a bit then show the app again
            DispatchQueue.main.asyncAfter(deadline: .now() + 1.0) {
                self.showAppAndCheckForScreenshot()
            }
        }
    }
    
    private func showAppAndCheckForScreenshot() {
        // Show the app window again
        if let window = NSApplication.shared.windows.first {
            window.makeKeyAndOrderFront(nil)
            NSApplication.shared.activate(ignoringOtherApps: true)
        }
        
        // Check for the most recent screenshot in the clipboard
        DispatchQueue.main.asyncAfter(deadline: .now() + 0.5) {
            self.checkClipboardForScreenshot()
        }
    }
    
    private func checkClipboardForScreenshot() {
        let pasteboard = NSPasteboard.general
        
        // Check if there's an image in the clipboard
        if let image = NSImage(pasteboard: pasteboard) {
            print("üì± [DEBUG] Found screenshot in clipboard, size: \(image.size)")
            
            // Cancel timeout timer
            screenshotTimeoutTimer?.invalidate()
            screenshotTimeoutTimer = nil
            
            // Set the image and start the multi-step flow
            selectedImage = image
            currentStep = 1
            selectedInputType = ""
            selectedProductType = ""
            descriptionText = ""
            
            // Clear the clipboard
            pasteboard.clearContents()
            
            // Reset capturing state since screenshot was successfully captured
            isCapturingScreenshot = false
            
            print("üì± [DEBUG] Screenshot added to chat and multi-step flow started")
                } else {
            print("üì± [DEBUG] No screenshot found in clipboard")
            print("üì± [DEBUG] Clipboard types: \(pasteboard.types ?? [])")
            
            // Try again after a short delay in case the screenshot is still being processed
            DispatchQueue.main.asyncAfter(deadline: .now() + 1.0) {
                self.checkClipboardForScreenshot()
            }
        }
    }
    
    private func resetConversation() {
        print("üì± [DEBUG] Reset conversation button tapped")
        
        // Clear all conversation data
        messages.removeAll()
        chatText = ""
        selectedImage = nil
        selectedTags.removeAll()
        
        // Reset multi-step flow
        currentStep = 1
        selectedInputType = ""
        selectedProductType = ""
        descriptionText = ""
        
        // Reset screenshot capturing state
        isCapturingScreenshot = false
        screenshotTimeoutTimer?.invalidate()
        screenshotTimeoutTimer = nil
        
        // Reset expanded images
        expandedImageIds.removeAll()
        
        // Stop any ongoing loading
        isLoading = false
        stopLoadingMessages()
        
    }
    
    private func handleStepAction() {
        switch currentStep {
        case 1:
            // Step 1: Check if input type is selected, then go to step 2
            if !selectedInputType.isEmpty {
                currentStep = 2
            }
        case 2:
            // Step 2: Check if product type is selected, then go to step 3
            if !selectedProductType.isEmpty {
                currentStep = 3
            }
        case 3:
            // Step 3: Send the final message
            sendFinalMessage()
        default:
            break
        }
    }
    
    private func isButtonDisabled() -> Bool {
        if isLoading {
            return true
        }
        
        if selectedImage != nil {
            switch currentStep {
            case 1:
                return selectedInputType.isEmpty
            case 2:
                return selectedProductType.isEmpty
            case 3:
                return descriptionText.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty
            default:
                return true
            }
        } else {
            return chatText.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty
        }
    }
    
    private func sendFinalMessage() {
        // Build the final message with all selected options
        var messageText = ""
        
        if !descriptionText.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty {
            messageText = descriptionText
        }
        
        // Add selected options
        let options = [selectedInputType, selectedProductType].filter { !$0.isEmpty }
        if !options.isEmpty {
            let optionsText = "Options: " + options.joined(separator: ", ")
            if messageText.isEmpty {
                messageText = optionsText
            } else {
                messageText = "\(messageText)\n\n\(optionsText)"
            }
        }
        
        // Add user message to chat
        let message = ChatMessage(text: messageText, image: selectedImage, sender: .user)
        messages.append(message)
        
        // Clear input and reset flow
        chatText = ""
        let imageToSend = selectedImage
        selectedImage = nil
        selectedTags.removeAll()
        currentStep = 1
        selectedInputType = ""
        selectedProductType = ""
        descriptionText = ""
        
        // Send to AI
        isLoading = true
        startLoadingMessages()
        
        Task {
            do {
                let response = try await dustService.sendMessage(
                    messageText.isEmpty ? "Please analyze this image." : messageText,
                    image: imageToSend
                )
                
                await MainActor.run {
                    let responseMessage = ChatMessage(text: response, sender: .agent)
                    messages.append(responseMessage)
                    isLoading = false
                    stopLoadingMessages()
                }
            } catch {
                await MainActor.run {
                    let errorMessage = ChatMessage(text: "Error: \(error.localizedDescription)", sender: .agent)
                    messages.append(errorMessage)
                    isLoading = false
                    stopLoadingMessages()
                }
            }
        }
    }
    
    
    
    private func addSampleAgentOutput() {
        let sampleOutput = """
‚≠êÔ∏è Business: 75/100 :
component A :
issues : add a üî¥
good : add a üü¢
‚≠êÔ∏è Experience: 60/100 :
component B :
issues : add a üî¥
good : add a üü¢
Most impactful improvement :
‚úÖ Solution 1 : Focus on improving the user onboarding flow to reduce drop-off rates
‚úÖ Solution 2 : Implement better error handling and user feedback mechanisms
"""
        messages.append(ChatMessage(text: sampleOutput, sender: .agent))
    }
    
    private func sendTaggedMessage(_ content: String) {
        let taggedMessage = "\(content)\n\nTell me more about this"
        
        // Add user message to chat
        messages.append(ChatMessage(text: taggedMessage, sender: .user))
        
        // Send to AI
        isLoading = true
        startLoadingMessages()
        
        Task {
            do {
                let response = try await dustService.sendMessage(taggedMessage, image: nil)
                
                await MainActor.run {
                    let responseMessage = ChatMessage(text: response, sender: .agent)
                    messages.append(responseMessage)
                    isLoading = false
                    stopLoadingMessages()
                }
            } catch {
                await MainActor.run {
                    let errorMessage = ChatMessage(text: "Error: \(error.localizedDescription)", sender: .agent)
                    messages.append(errorMessage)
                    isLoading = false
                    stopLoadingMessages()
                }
            }
        }
    }
    
    private func sendMessage() {
        let trimmedText = chatText.trimmingCharacters(in: .whitespacesAndNewlines)
        
        // Don't send if both text and image are empty
        guard !trimmedText.isEmpty || selectedImage != nil else { return }
        
        // Build the message with selected tags
        var messageText = trimmedText.isEmpty ? "" : trimmedText
        
        // Add selected tags to the message
        if !selectedTags.isEmpty {
            let tagsText = "Tags: " + selectedTags.sorted().joined(separator: ", ")
            if messageText.isEmpty {
                messageText = tagsText
            } else {
                messageText = "\(messageText)\n\n\(tagsText)"
            }
        }
        
        // Add user message to chat
        let message = ChatMessage(text: messageText, image: selectedImage, sender: .user)
        messages.append(message)
        
        // Clear input and reset tags
        chatText = ""
        let imageToSend = selectedImage
        selectedImage = nil
        selectedTags.removeAll()
        
        // Send to AI
        isLoading = true
        startLoadingMessages()
        
        Task {
            do {
                let response = try await dustService.sendMessage(
                    messageText.isEmpty ? "Please analyze this image." : messageText,
                    image: imageToSend
                )
                
                await MainActor.run {
                    let responseMessage = ChatMessage(text: response, sender: .agent)
                    messages.append(responseMessage)
                    isLoading = false
                    stopLoadingMessages()
                }
            } catch {
                await MainActor.run {
                    let errorMessage = ChatMessage(text: "Error: \(error.localizedDescription)", sender: .agent)
                    messages.append(errorMessage)
                    isLoading = false
                    stopLoadingMessages()
                }
            }
        }
    }
}
